# Exception Anti-Patterns #

A lot has been written about exception anti-patterns, but I still see them everywhere in the production code that I work with. The anti-patterns are all simple to understand, but people don't seem to be able to live without them. From some of the work I've seen, and some of the people I've talked to, I get the impression that, while developers may know what not to do, they don't have a reasonable replacement. So rather than repeating the same anti-patterns, I sat down to develop guidelines about proper handling of exceptions. 

Exceptions are often an overlooked issue. Developers will go into a task with a clear idea of how to solve a particular problem, but won't have a clear idea of how to respond if something goes wrong. So, on a multi-person team, often each developer will follow a different approach, so a project will follow many different philosophies for how to handle exceptions.

The first thing to say about Exceptions is that there are two different kinds, checked and unchecked. Rather than understanding them by the semantics of the Java language, it's more useful to know that they each have a different purpose, so you should think about them differently. In general, checked exceptions are for conditions that you can still expect to see, even when your code is properly written, complete, and free of bugs. For example, if a user requests information that doesn't exist, this may generate a checked Exception. 

An unchecked exception means there's a bug in your code. 

Even if you're using a language like Kotlin, which doesn't have checked exceptions, it's still useful to think of two different categories of exceptions: Those that you expect to handle in finished, bug-free code, and those that are generated by bugs. Much of this essay will focus on unchecked exceptions, because that's where things go awry, but it's still important to understand the distinction.

Second, many developers are under the impression that one mark of a good developer is in knowing when to catch exceptions. They catch all sorts of exceptions, careful to make sure nothing can possibly go wrong. But this produces a lot of code bloat, and seriously complicates the code. It often hides bugs instead of exposing them so they can be fixed. When it comes to exceptions, the mark of a good developer isn't knowing when to catch one, it's knowing when to throw one.

With that in mind, here are some guidlines.

## 1. Trust Your Framework.
Your code should have an UncaughtExceptionHandler to log any uncaught Throwables. You can set it by calling the static `Thread.setDefaultUncaughtExceptionHandler()` method, and you can find out if one is set with the static `Thread.getDefaultUncaughtExceptionHandler()` method. If you don't set one, all exceptions should be caught in the outermost layer of your code. What this means is that *all exceptions will get logged!* You don't need to catch an Exception just to make sure it gets logged. It does get logged.

Unless it doesn't. This can happen, and it's due to a fairly uncommon bug, but which you should know about. Sometimes, someone up the call stack is catching and swallowing an Exception without even logging it. This is a serious bug, and should be rooted out. Fortunately, once you figure out that an Exception is getting swallowed, you can find the culprit by setting a breakpoint and searching up the call stack for the problematic catch statement. Often the problem is because somebody knew an Exception could show up that could be safely ignored, but wrote `catch (Exception e)` instead of catching the specific subclass of Exception that they needed to swallow. Bugs like this should always be fixed, so you can go back to trusting your framework.

## 2. Trust Your Code.
That's right. Don't worry about bugs. Assume all of your methods work properly.

Huh? Of course you should worry about bugs! But don't try to supress them by catching the exceptions they generate. Instead, supress them by fixing them. In a well-written, bug free piece of code, you won't see any RuntimeExceptions. So don't write code to catch them. If you look through the code of classes in the JDK, you won't find any cases where they say `catch (RuntimeException e).` They don't do this because, when they wrote their code, they assumed they would reach a bug-free state, and none of these catch statements would be necessary. You should do the same thing.

But on a lot of projects, you'll see RuntimeExceptions getting caught all over the place. Once the code is working, these aren't necessary. There will be bugs in your code at first. Let the Exceptions they generate pass right through your code and get logged, so you can find them and fix them. So when you write your code, assume all the methods you call are bug-free, and don't worry about any bugs until you actually see them. If you call a buggy method, it's not the responsibility of your method to catch it and recover from it. You most likely can't recover from it anyway. Let the `UncheckedExceptionHandler` log it, so you can fix it at the source.

## 3. Trust Your Exceptions.
Many developers try to suppress all Exceptions. This sounds like an excellent idea because you don't want to see Exceptions in production code. But they're just executing the messenger. It's bugs they should be trying to suppress. *Exceptions are **not** bugs.* Exceptions are the trail of breadcrumbs that lead you to the bugs. Bugs are bad. Exceptions are good. They help you kill the bugs.

Remember that an unchecked exception means there's a bug in your code. Don't hide it by catching the exception, fix it. And don't ever try to recover from it. *There's no recovering from a bug.* Bugs should be fixed, not recovered from. Let it pass through to your `UncaughtExceptionHandler` so you can see it and fix it.

If you're writing a service and need to return a response, you can't realistically let the `UncaughtExceptionHandler` handle it. Instead, depending on your framework, you can either install a filter that maps Exceptions to specific resonses, or catch the exception in the outer-most method of the service, log it, and construct a proper error response. (You don't have to catch it in the outer-most layer, but that's often the cleanest place to handle it.) You may decide you need to generate error responses elsewhere in the code, because you need to provide special information about a permissible and documented failure condition. For example, if a client searches for a user that doesn't exist, the service will fail to find them, but this is not due to a bug in your code. So keep in mind that bugs and permissable failures are not the same thing, and you should not handle them the same way. A bug should generate its own response that can be distinguished from a permissible failure. This makes it easier to identify and fix.

## 4. Trust Your Input
If a function receives valid input, it should return a valid result. If it receives invalid input, it should throw an exception. *The proper behavior for invalid input is to throw an exception.* The invalid input is likely caused by a bug, and the Exception's stack trace will usually help you catch it.

## 5 Trust Your Data
Yeah, I know. This one is much tougher than any of the others. Problems in the data are the whole reason people catch all those Exceptions that I'm trying to discourage. They're the rotting corpse from which the bugs hatch. On many projects, I've seen people preface every method call with `if (someObject != null) {`, being ever so cautious that the data could be bad. And it often is, even in a running system. It doesn't help that a lot of database tables are filled with optional fields that do need to be tested. What's the proper approach? Here are some data guidelines.
### 5.a Validate on Data Entry
In principal, you shouldn't ever put bad data into your database. So when you pull an object out of a database, you should trust it to be valid. If it's not, if there's a null field that need a valid value, then go back to your database validation methods to see where it failed to get set. And throw an Exception describing the missing data. 
### 5.b Write Your Requirements into Your Table Design
Some database columns are allow null values, while others don't. Often, when the database is designed, people default to nullable columns without giving it much thought. This is a bad idea. Instead, you should carefully consider which fields are essential, and mark them as NOT NULL. Then add that information to your JavaDocs, so your users can see which values don't need to be tested. For text fields, prefer empty fields to null values. Then, when you're 
### 5.c Check for Validity on Retrieval
This is most important. Don't ask a method to validate its inputs. That's the responsibility of the method that's making the call. 

*(Where do I put this part?)*

Many developers will do quick validation checks at the beginning of a method, throwing an Exception if a parameter is null. These tests are often unnecessary, because they're about to use the object, which will generate a `NullPointerException` anyway. But sometimes a parameter doesn't get used, it just gets set inside an object, to be used later. This may be a good time to validate the object. But a more sensible policy is the Validate data as it comes into a system, usually through external input.

# Antipatterns

## 1 Catch, Log, Return null ##

    public HtmlEmailBuilder getEmailBuilder( /* several parameters */ ) {
        HtmlEmailBuilder builder = new HtmlEmailBuilder();
        try {
            // ~150 lines of code deleted.

                return builder;
            }
        } catch (Exception e) {
            LOGGER.error("getEmailBuilder", e);
        }
        return null;
    }

I was asked to debug a NullPointerException in a web service, but the stack trace in the bug report didn't help, because it was caused by the null value returned by this method. Of course, a more useful stack trace was right there in the log, but whoever filed the bug didn't know that, so I got the wrong stack trace in the bug report.

I'm not sure what the developer was thinking in returning null, which is usually a useless value. Maybe s/he assumed that the calling method would test it for null. But there's really no point to this, especially in a web server. If the developer had just ignored the exception, it would have been logged anyway, and my bug report would have had the correct stack trace.

A second problem is that it catches Exception, rather than a more specific Exceptoin. When I see this, I have no way of knowing if a checked exception is getting thrown, so I always change it to RuntimeException, to see if I get a compiler error. In this case, I didn't.

Was the developer was just being conscientious, thinking that it's a better practice to catch and log any Exceptions? But it's not. The NullPointerException got logged. That happens automatically. As developers, we should trust that the calling code will correctly log any exceptions that our code throws. And if they don't, that's the first bug that needs to get fixed.

So when is null an acceptable return value? Looking through the APIs that come with the JDK, you may notice that null is typically returned when a method is searching for something that might not be there, like the `Map.get()` method. Since JDK 1.8, many new methods will now return an Optional instead. But Optional is not a good alternative for the method above. It shouldn't be used to mean something went wrong. The method above is supposed to always return a valid object. It will only return null if there's a bug in the code, or if it recieved invalid input. The proper behavior for invalid input is to throw an Exception, not to return null.

## No Exceptions in Released Code ##

I've worked on projects where we had a rule that exceptions were forbidden in released code. This led to a lot of code where we checked nearly all returned values for null. This led to some comical warnings issued by my IDE. For example I often saw cases like this:

    public void someMethod(Thing someThing, ...) {
        Widget widget = someThing.getWidget();
        ...
        if (someThing != null) {
            someThing.someMethod(...);
        }

My IDE would warn me that `someThing != null` is always true. It knows because the previous call to `getWidget()` would have thrown a NullPointerException if it was null. I saw this warning all over the place.

Why did they do this? While this particular application was a client-server application, it wasn't a browser client. It was a stand-alone client written in Java/Swing. So the thinking was that an exception in the client would be seen only by the client, and wouldn't go into the server logs anyway. So the customer would see the exception but we wouldn't. But it would have been a simple task to report all client exceptions back to the server, where we could debug them.
