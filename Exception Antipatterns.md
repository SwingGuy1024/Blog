***This is a work in progress. I still have a lot to add. At this point, it should be read as an incomplete rough draft.***

# Introduction
On a recent project I joined, I found lots of methods that started out something like this:

    void doSomething(Widget widget, [more parameters]) {
      if (widget != null) {
        widget.doSomethingImportant();
        // ... more code
      }
    }
    
The test for null comes from a certain kind of contientious developer, who is trying suppress a possible bug, to ensure no exception will be thrown in production code. But what happens if `widget` is null here? The method will do nothing, and fail silently. An exception would certainly get suppressed, but the bug would remain, hidden from view. There are a lot of developers who write code like this, which can result in bugs safely hidden deep in the code where they will be harder to find. Is this really wise?

Or should we take the opposite approach, writing code to encourage every bug to announce its presence at the earliest opportunity? This is the approach I like to take, and in my experience, it not only results in code that's less buggy, it also produces code that's less complex, easier to debug, and easier to maintain. 

When it comes to exceptions, many developers are under the impression that a mark of a good developer is in knowing when to catch them. They catch all sorts of exceptions, careful to make sure nothing can possibly go wrong. But this produces a lot of code bloat, complicates the code, and, like my example above, it often hides bugs instead of exposing them so they can be fixed. I see this as the wrong approach. When it comes to exceptions, the mark of a good developer isn't knowing when to catch one, it's knowing when to throw one.

# Guidelines for Catching and Throwing Exceptions

A lot has been written about exception anti-patterns, but I still see them everywhere in the production code that I work with. The anti-patterns are all simple to understand, but some people can't seem to live without them. From some of the code I've seen, and some of the people I've talked to, I get the impression that, while developers may know what not to do, they don't have a reasonable replacement. So rather than repeating the same anti-patterns, I sat down to develop guidelines about proper handling of exceptions. The well known anti-patterns emerge from these guidelines, but it's more useful to know the guidelines than the anti-patterns.

Exceptions are often an overlooked issue. Developers will go into a task with a clear idea of how to solve a particular problem, but won't have a clear idea of how to respond if something goes wrong. So, on a multi-person team, often each developer will follow a different approach, so a project will follow many different philosophies for how to handle exceptions.

The first thing to say about Exceptions is that there are two different kinds, checked and unchecked. Rather than understanding them by the semantics of the Java language, it's more useful to know that they each have a different purpose, so you should think about them differently. In general, checked exceptions are for conditions that you can still expect to see, even when your code is properly written, complete, and free of bugs. For example, if a user requests information that doesn't exist, this may generate a checked exception. 

An unchecked exception usually means there's a bug in your code. These are the exceptions that I'm concerned with.

Even if you're using a language like Kotlin, which doesn't have checked exceptions, it's still useful to think of two different categories of exceptions: Those that you expect to handle in finished, bug-free code, and those that are generated by bugs. Much of this essay will focus on unchecked exceptions, because that's where things go awry, but that makes it important to understand the distinction.

With that in mind, here are some guidlines.

### 1. Trust Your Framework.
Your code should have an UncaughtExceptionHandler to log any uncaught Throwables. You can set it by calling the static `Thread.setDefaultUncaughtExceptionHandler()` method, and you can find out if one is set with the static `Thread.getDefaultUncaughtExceptionHandler()` method. If you don't set one, all exceptions should be caught in the outermost layer of your code. What this means is that *all exceptions will get logged!* You don't need to catch an Exception just to make sure it gets logged. It does get logged.

If you're writing a service and need to return a response, you can't realistically let the `UncaughtExceptionHandler` handle it. Instead, depending on your framework, you can either install a filter that maps Exceptions to specific responses, or catch the exception in the outer-most method of the service, log it, and construct a proper error response. You may decide you need to generate error responses elsewhere in the code, because you need to provide special information about a permissible and documented failure condition. For example, if a client searches for a user that doesn't exist, the service will fail to find them, but this is not due to a bug in your code. So keep in mind that bugs and permissable failures are not the same thing, and you should not handle them the same way. A bug should generate its own response that can be distinguished from a permissible failure. This makes it easier to identify and fix. But any exception generated by an uncaught bug will get passed to your outer service layer, or to your `uncaughtExceptionHandler,` so it does get logged.

Unless it doesn't. This can happen, and it's due to a fairly uncommon bug, but which you should know about. Sometimes, some code up the call stack is swallowing all exceptions without logging them. This can result in code that fails without throwing any exceptions. This is a serious bug, and should be rooted out. Fortunately, once you suspect that an exception may be getting swallowed, you can find the culprit by setting a breakpoint and searching up the call stack for the problematic catch statement. Often the problem is because somebody knew a certain Exception could show up that could be safely ignored, but used the overly broad `catch (Exception e)` instead of catching the specific subclass of Exception that they needed to swallow. Bugs like this should always be fixed, so you can go back to trusting your framework.

### 2. Trust Your Code.
That's right. Don't worry about bugs. Assume all of your methods work properly.

Huh? Of course you should worry about bugs! But don't try to supress them by catching the exceptions they generate. Instead, supress them by fixing them. In a well-written, bug free piece of code, you won't see any RuntimeExceptions. So don't write code to catch them. If you look through the code of classes in the JDK, you won't find any cases where they say `catch (RuntimeException e).` They don't do this because, when they wrote their code, they assumed they would reach a bug-free state, and none of these catch statements would be necessary. The HashMap class is a good example. In nearly 2400 lines, they only catch a single exception, and it's a checked exception. (It's the `CloneNotSupportedException` in the `clone()` method.) Every method they call, they trust that it will work correctly. You should do the same thing.

But on a lot of projects, you'll see RuntimeExceptions getting caught all over the place. Once the code is working, these aren't necessary. Sure, there will be bugs in your code at first. Let the exceptions they generate pass right through your code and get logged, so you can find them and fix them. When you write your code, don't worry about any bugs until you actually see them. Assume all the methods you call are bug-free. At first they're not, but you'll get there. If you call a buggy method, it's *not* your responsibility to catch it and recover from it. Your responsibility is to root out the bugs from the code you're writing, not from the methods you call. The useful irony is by trusting code that actually still has bugs, you'll find those bugs more quickly and fix them sooner.

### 3. Trust Your Exceptions.
Many developers try to suppress all exceptions. At first, this sounds like an excellent idea because you don't want to see exceptions in production code. But they're just executing the messenger. It's bugs they should be trying to suppress. *Exceptions are **not** bugs.* Exceptions are the trail of breadcrumbs that lead you to the bugs. Bugs are bad. Exceptions are good. They help you kill the bugs.

Remember that an unchecked exception means there's a bug in your code. Don't hide it by catching the exception, fix it. And don't ever try to recover from it. *There's no recovering from a bug.* Bugs should be fixed, not recovered from. You most likely can't recover from it anyway, and any attempts to do so will only make things worse. Let it pass through to your `UncaughtExceptionHandler` so you can see it and fix it.

### 4. Trust Your Method Parameters
If a function receives valid input, it should return a valid result. If it receives invalid input, it should throw an exception. *The proper behavior for invalid input is to throw an exception.* The invalid input is likely caused by a bug, and the exception's stack trace will usually help you catch it. If your method parameters are bad, your code will most likely throw an Exception without any effort on your part. Let it do this.

### 5. Don't Trust Your Constructor Parameters
This is the exception to the previous rule. Constructors do have the responsibility to ensure the object is properly constructed. So this follows the same principle that the proper behavior for invalid input is to throw an exception. With methods, this usually happens on its own, as you try to use the parameters. But with constructors, invalid values get set as members, where they will cause bugs long after the constructor has finished its work. In those cases, whatever stack traces they generate won't point back to the code that set the value, they'll just point to the invalid value. This is why constructors should reject invalid input by throwing an unchecked exception.

### 6 Trust Your Data
Yeah, I know. This one is much tougher than any of the others. Problems in the data are the whole reason people catch all those exceptions that I'm trying to discourage. They're the rotting corpse from which the bugs hatch. On many projects, I've seen people preface every method call with `if (someObject != null) {`, being ever so cautious that the data could be bad. And it often is, even in a running system. It doesn't help that a lot of database tables are filled with optional fields that do need to be tested. What's the proper approach? Here are some data guidelines.

#### 6.a Validate on Data Entry
In principal, you shouldn't ever put bad data into your database. So when you pull an object out of a database, you should trust it to be valid. If it's not, if there's a null field that need a valid value, then go back to your database validation methods to see where it failed to get set. And throw an exception describing the missing data. The idea here is that *data should be validated when it comes into your application.* Once it has been validated, trust it. Once again, there will be bugs in your data. You'll find them as you excercise your application.

#### 6.b Validate if necessary on data retrieval
I've seen many `if (x != null)` tests on objects taken from the many-end of a one-to-many relationship, which means they couldn't possibly be null. By itself, testing for null is pretty harmless, as long as you throw an exception if the object is not supposed to be null.

#### 6.c Validate on object modification
Here's an improvement of my original example that doesn't hide the null-widget bug, but that makes an unnecessary test.

    void doSomething(Widget widget, [more parameters]) {
      if (widget != null) {
        widget.doSomethingImportant();
        // ... more code
      } else {
        throw new NullPointerException("Widget is null");
      }
    }
Testing for null and throwing an exception isn't needed at all. If widget isn't tested for null, it will still throw a NullPointerException. But here's a different case, where a test for null is much more important:

    void doSomething(Widget widget, Thing thing, [more parameters]) {
      if (widget != null) {
        thing.setWidget(widget);     // Here, thing is getting modified.
        // ... more code
      } else {
        throw new NullPointerException("Widget is null");
      }
    }
    
Here, the test for null is very useful, because the null object is being saved for later use. When somebody tries to use it, it will generate a NullPointerException that doesn't point back to the place where the null value was set. So here, it is the responsibility of this method to ensure `widget` is a valid object, *because it's being used to modify another object.*

#### 6.d Validation Responsibility Belongs With the Data Supplier
Methods that begin with the `if (x != null)` check are written with the assumption it's their responsibility to validate the data. But it's not. Responsibility lies with the method that supplies the data to the methods it calls, and to the deeper methods that they call. Once the data has been supplied, the methods that use it and pass it around should assume it's valid, which will result in an exception getting thrown if it's not.

### An Anecdote
To illustrate this, let's go back to my original example, with a small modification. I would often see code like this:

    1  void doSomething(Widget widget, [more parameters]) {
    2    widget.prepareForSomethingImportant(someData);)
    3    if (widget != null) {              // inspection failure here: widget can't be null
    4      widget.doSomethingImportant();
    5      // ... more code
    6    }
    7  }

In this method, my IDE would give me a warning that the test on line 3 is unnecessary, because `widget` can't be null. (Can you spot why?) The reason is simple. If `widget` was null, it would never reach line 3, because a NullPointerException would get thrown on line 2. 

But we never saw this exception, so I decided to dig a little deeper. I set a break point and looked at who called this method. The first thing I noticed was that `widget` had already been tested for null in the previous method. So I went up the call stack and I found the same thing, over and over again. It turned out that `widget` had been tested for null eleven times before reaching this method. To top it off, it had been retrieved from a database in a way that already guaranteed it couldn't be null.

If it needed validation at all, it was only when it was retrieved from the database. Trust your data. If it's bad, you'll find out. And you'll be able to fix it.

### Favor the More Restrictive Exceptions
If you say `catch (Exception e)` because you called a method that is declared `throws IOException,` You may find your code catching more than you need. I once spent three hours trying to track down a bug that should have been easy to catch. I finally narrowed it down to a single statement that should have been throwing a `NullPointerException,` which I was mysteriously not seeing. It turned out that my exception was getting caught and ignored higher up the call stack, because somebody had caught all exceptions instead of just catching the IOException that his code could throw. This illustrates how saying `catch (Exception e)` or `throws Exception` will actually run the risk of introducing new bugs. 

#### A Word about Table Design
Some database columns are allow null values, while others don't. Often, when the database is designed, people default to nullable columns without giving it much thought. This is a bad idea. Instead, you should carefully consider which fields are essential, and mark them as NOT NULL. Then add that information to your JavaDocs, so your users can see which values don't need to be tested. For text fields, prefer empty fields to null values.

# Antipatterns

## 1 Catch, Log, Return null ##

    public HtmlEmailBuilder getEmailBuilder( /* several parameters */ ) {
        HtmlEmailBuilder builder = new HtmlEmailBuilder();
        try {
            // ~150 lines of code deleted.

                return builder;
            }
        } catch (Exception e) {
            LOGGER.error("getEmailBuilder", e);
        }
        return null;
    }

I was asked to debug a NullPointerException in a web service, but the stack trace in the bug report didn't help, because it was caused by the null value returned by this method. Of course, a more useful stack trace was right there in the log, but whoever filed the bug didn't know that, so I got the wrong stack trace in the bug report.

I'm not sure what the developer was thinking in returning null, which is usually a useless value. Maybe s/he assumed that the calling method would test it for null. But there's really no point to this, especially in a web server. If the developer had just ignored the exception, it would have been logged anyway, and my bug report would have had the correct stack trace.

A second problem is that it catches exception, rather than a more specific Exceptoin. When I see this, I have no way of knowing if a checked exception is getting thrown, so I always change it to RuntimeException, to see if I get a compiler error. In this case, I didn't.

Was the developer was just being conscientious, thinking that it's a better practice to catch and log any exceptions? But it's not. The NullPointerException got logged. That happens automatically. As developers, we should trust that the calling code will correctly log any exceptions that our code throws. And if they don't, that's the first bug that needs to get fixed.

So when is null an acceptable return value? Looking through the APIs that come with the JDK, you may notice that null is typically returned when a method is searching for something that might not be there, like the `Map.get()` method. Since JDK 1.8, many new methods will now return an Optional instead. But Optional is not a good alternative for the method above. It shouldn't be used to mean something went wrong. The method above is supposed to always return a valid object. It will only return null if there's a bug in the try block, or if it recieved invalid input. The proper behavior for invalid input is to throw an exception, not to return null.

## Preventing Exceptions ##

I've worked on projects where we had a rule that exceptions were forbidden in released code. This led to a lot of code where we checked nearly everything for null before using it, like this.

    public void someMethod(Widget widget, ...) {
        if (widget != null) {
            widget.someMethod(something, ...);
        }
    }

If Widget is null, this method won't throw an exception, it will fail silently. The NullPointerException that gets suppressed will tell you where the bug is. Don't suppress it.

## Log and Throw ##
*3 Examples:*

    catch (NoSuchMethodException e) { LOG.error("Blah", e); throw e; }
    catch (NoSuchMethodException e) { LOG.error("Blah", e); throw new SomeGenericException("message", e); }
    catch (NoSuchMethodException e) { e.printStackTrace(); throw new SomeGenericException("message", e); }

Trust your framework. Your exception will get logged. Doing this will result in your exception getting logged twice. If it's a checked exception and you can't recover from it, it's due to a bug. You can wrap it in an unchecked exception and rethrow it. Some people will say either log it or throw it, but never do both. I see the logic behind this, but I say just throw it, and trust that it will get logged.

## Destructive Wrapping ##
*Example:*

    catch (NoSuchMethodException e) { throw new SomeGenericException(e.getMessage()); }

This swallows the stack trace of the original exception. Instead, pass the original exception to the constructor:

    catch (NoSuchMethodException e) { throw new SomeGenericException(e.getMessage(), e); }

Sometimes the exception you need to throw doesn't have a constructor with a cause parameter. In that case, you can pass it by using the `initCause()` method in a chained call:

    catch (NoSuchMethodException e) { throw new SomeGenericException(e.getMessage()).initCause(e); }

## Catch Exception ##
Example:

    try { 
      doSomeStuff();
    } catch (Exception e) {
      // try to recover, or maybe log something
    }

Whenever I see this, I always wonder if there is some specific checked exception that we need to catch, or if the developer just wanted to catch whatever might get thrown. If I'm working on the class, I will change it RuntimeException, just to see if it generates a compiler error. (It usually doesn't, which means it's probably not even necessary)

There are a few things wrong with this. First of all, catching Exception, or (worse) Throwable, is way too broad, and risks catching additional unchecked exceptions that you want to get logged by the uncheckedExceptionHandler. 
    
This is generally wrong and sloppy. Catch the specific exceptions that can be thrown. The problem with catchingException is that if the method you are calling later adds a new checked exception to its method signature, the developer's intent is that you should handle the specific new exception. If your code just catches Exception (or worse, Throwable), you'll probably never know about the change and the fact that your code is now wrong.

## Declaring "throws Exception" ##
*Example:*

    public void foo() throws Exception { ... }

You can provide more information than that. Not only does this fail to specify what is getting thrown, it forces the caller to use an overly broad catch expression. That will catch RuntimeExceptions that should be allowed to pass through to your uncaughtExceptionHandler. 


##### (Borrowed. Rewrite and expand)

Throwing the Kitchen Sink
Example:

public void foo() throws MyException, AnotherException, SomeOtherException, YetAnotherException {
Throwing multiple checked exceptions from your method is fine, as long as there are different possible courses of action that the caller may want to take, depending on which exception was thrown. If you have multiple checked exceptions that basically mean the same thing to the caller, wrap them in a single checked exception.




Log and Return Null
Example:

catch (NoSuchMethodException e) { LOG.error("Blah", e); return null; }
or

catch (NoSuchMethodException e) { e.printStackTrace(); return null; } // Man I hate this one
Although not always incorrect, this is usually wrong. Instead of returning null, throw the exception, and let the caller deal with it. You should only return null in a normal (non-exceptional) use case (e.g., "This method returns null if the search string was not found.").

Catch and Ignore
Example:

catch (NoSuchMethodException e) { return null; }
This one is insidious. Not only does it return nullinstead of handling or re-throwing the exception, it totally swallows the exception, losing the information forever.

Throw from Within Finally
Example:

try { blah(); } finally { cleanUp(); }
This is fine, as long as cleanUp() can never throw an exception. In the above example, if blah() throws an exception, and then in the finally block,cleanUp() throws an exception, that second exception will be thrown and the first exception will be lost forever. If the code that you call in a finally block can possibly throw an exception, make sure that you either handle it, or log it. Never let it bubble out of the finally block.

Multi-Line Log Messages
Example:

LOG.debug("Using cache policy A"); LOG.debug("Using retry policy B");
Always try to group together all log messages, regardless of the level, into as few calls as possible. So in the example above, the correct code would look like:

LOG.debug("Using cache policy A, using retry policy B");
Using a multi-line log message with multiple calls tolog.debug() may look fine in your test case, but when it shows up in the log file of an app server with 500 threads running in parallel, all spewing information to the same log file, your two log messages may end up spaced out 1000 lines apart in the log file, even though they occur on subsequent lines in your code.

Unsupported Operation Returning Null
Example:

public String foo() { // Not supported in this implementation. return null; }
When you're implementing an abstract base class, and you're just providing hooks for subclasses to optionally override, this is fine. However, if this is not the case, you should throw an UnsupportedOperationExceptioninstead of returning null. This makes it much more obvious to the caller why things aren't working, instead of her having to figure out why her code is throwing some randomNullPointerException.

IgnoringInterruptedException
Example:

while (true) { try { Thread.sleep(100000); } catch (InterruptedException e) {} doSomethingCool(); }
InterruptedException is a clue to your code that it should stop whatever it's doing. Some common use cases for a thread getting interrupted are the active transaction timing out, or a thread pool getting shut down. Instead of ignoring theInterruptedException, your code should do its best to finish up what it's doing, and finish the current thread of execution. So to correct the example above:

while (true) { try { Thread.sleep(100000); } catch (InterruptedException e) { break; } doSomethingCool(); }
Relying on getCause()
Example:

catch (MyException e) { if (e.getCause() instanceof FooException) { ...
The problem with relying on the result of getCauseis that it makes your code fragile. It may work fine today, but what happens when the code that you're calling into, or the code that it relies on, changes its underlying implementation, and ends up wrapping the ultimate cause inside of another exception? Now calling getCause may return you a wrapping exception, and what you really want is the result ofgetCause().getCause(). Instead, you should unwrap the causes until you find the ultimate cause of the problem. Apache'scommons-langproject provides ExceptionUtils.getRootCause()to do this easily.

###### Principles

1.  All uncaught exceptions will get logged.
2.  Exceptions are not bugs. They're the bread crumb trail that lead you to the bugs.
3.  There is no recovering from a bug.
4.  Catch only what you need to catch.
5.  The proper behavior for invalid data is to throw an unchecked exception.
6.  Validation responsibility belongs with the data supplier.
6a. Validated data when you bring it into your application.
6b. Validate on object construction.
6c. Validate on object modification.
